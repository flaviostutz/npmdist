import * as fs from 'node:fs';
import * as path from 'node:path';

import { readJsonFile, writeJsonFile } from './utils';
import { PublishablePackageJson } from './types';

/**
 * Configuration for the publisher initializer
 */
export interface PublisherInitConfig {
  /**
   * Working directory where to initialize (default: current working directory)
   */
  workingDir?: string;
}

/**
 * Result of the init process
 */
export interface InitResult {
  /**
   * Whether initialization was successful
   */
  success: boolean;

  /**
   * Message describing the result
   */
  message: string;

  /**
   * List of folders that were included in publishing
   */
  publishedFolders?: string[];

  /**
   * Path to the updated package.json
   */
  packageJsonPath?: string;
}

/**
 * PublisherInit utility for setting up package publishing configuration
 */
export class PublisherInit {
  private readonly config: PublisherInitConfig & { workingDir: string };

  constructor(config?: PublisherInitConfig) {
    this.config = {
      workingDir: process.cwd(),
      ...config,
    };
  }

  /**
   * Validate that all folders exist
   */
  private validateFolders(folders: string[]): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    for (const folder of folders) {
      const folderPath = path.join(this.config.workingDir, folder);
      if (!fs.existsSync(folderPath)) {
        errors.push(`Folder not found: ${folder}`);
      } else if (!fs.statSync(folderPath).isDirectory()) {
        errors.push(`Not a directory: ${folder}`);
      }
    }

    return { valid: errors.length === 0, errors };
  }

  /**
   * Generate a CLI script template that uses the folder-publisher library CLI
   */
  private generateCliScript(): string {
    return `#!/usr/bin/env node

// DON'T EDIT THIS FILE MANUALLY
// This script is generated by "folder-publisher init" command
// It serves as a simple wrapper around the folder-publisher CLI to extract the package contents

const { execSync } = require('child_process');
const path = require('path');
const fs = require('fs');

async function main() {
  const pkg = JSON.parse(fs.readFileSync(path.join(__dirname, '../package.json')).toString());
  
  // Execute the folder-publisher CLI with this package as the target
  const fpCliPath = require.resolve('folder-publisher/dist/main.js');
  const command = \`node "\${fpCliPath}" "\${pkg.name}" extract "\${process.cwd()}"\`;
  
  execSync(command, { stdio: 'inherit' });
}

main();
`;
  }

  /**
   * Prepare package.json configuration for publishing
   * Mutates and returns the configuration object with normalized fields and publishing setup
   */
  private preparePackageJsonConfig(
    folders: string[],
  ): PublishablePackageJson {
    const packageJsonPath = path.join(this.config.workingDir, 'package.json');

    let packageJson: PublishablePackageJson;

    if (fs.existsSync(packageJsonPath)) {
      packageJson = readJsonFile<PublishablePackageJson>(packageJsonPath);
    } else {
      // Create a minimal package.json
      packageJson = {
        name: path.basename(this.config.workingDir),
        version: '1.0.0',
      };
    }

    // Ensure name exists
    if (!packageJson.name) {
      packageJson.name = path.basename(this.config.workingDir);
    }

    // Ensure version exists
    if (!packageJson.version) {
      packageJson.version = '1.0.0';
    }

    // Update files field to include selected folders
    // Build new folder patterns based on current folders parameter
    const newFolderPatterns = folders.map((folder) => `${folder}/**`);

    // Preserve existing patterns (both folder and non-folder) to avoid removing user tweaks
    const existingPatterns = (packageJson.files as string[]) || [];
    const existingFolderPatterns = existingPatterns.filter((pattern: string) =>
      pattern.endsWith('/**'),
    );
    const existingNonFolderPatterns = existingPatterns.filter(
      (pattern: string) => !pattern.endsWith('/**'),
    );

    // Combine and deduplicate using Set to prevent duplicates
    const filesPatterns = Array.from(
      new Set([
        ...newFolderPatterns,
        ...existingFolderPatterns,
        ...existingNonFolderPatterns,
        'package.json',
        'bin/folder-publisher-extract.js',
      ]),
    );

    packageJson.files = filesPatterns;

    // Add folder-publisher as a dependency
    if (!packageJson.dependencies) {
      packageJson.dependencies = {};
    }
    packageJson.dependencies['folder-publisher'] = 'latest';

    // Add bin field to make it executable via npx
    if (!packageJson.bin) {
      packageJson.bin = 'bin/folder-publisher-extract.js';
    }

    return packageJson;
  }

  /**
   * Initialize publisher configuration with specified folders
   */
  public async init(folders: string[]): Promise<InitResult> {
    try {
      if (!folders || folders.length === 0) {
        return {
          success: false,
          message: 'folder-publisher: no folders specified. Usage: folder-publisher init <folder1> <folder2> ...',
        };
      }

      // Validate folders exist
      const validation = this.validateFolders(folders);
      if (!validation.valid) {
        return {
          success: false,
          message: `folder-publisher: folder validation failed:\n${validation.errors.join('\n')}`,
        };
      }

      // Prepare package.json configuration
      const packageJson = this.preparePackageJsonConfig(folders);
      const packageJsonPath = path.join(this.config.workingDir, 'package.json');

      // Write updated package.json
      writeJsonFile(packageJsonPath, packageJson);

      // Write CLI script to root directory
      const cliScriptPath = path.join(this.config.workingDir, 'bin', 'folder-publisher-extract.js');
      fs.mkdirSync(path.dirname(cliScriptPath), { recursive: true });
      const cliScript = this.generateCliScript();
      fs.writeFileSync(cliScriptPath, cliScript, 'utf-8');
      fs.chmodSync(cliScriptPath, 0o755);

      return {
        success: true,
        message: 'folder-publisher: project initialization completed successfully',
        publishedFolders: folders,
        packageJsonPath,
      };
    } catch (error) {
      return {
        success: false,
        message: `folder-publisher: initialization failed: ${String(error)}`,
      };
    }
  }
}
