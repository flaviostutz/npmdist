/* eslint-disable functional/immutable-data */
/* eslint-disable no-restricted-syntax */
import fs from 'node:fs';
import path from 'node:path';

import { readJsonFile, writeJsonFile, parsePackageSpec } from './utils';
import { PublishablePackageJson, NpmdataExtractEntry } from './types';

/**
 * Read the version of the currently running npmdata package so we can pin it
 * in the generated package.json rather than using 'latest'.
 */
function getOwnVersion(): string {
  // eslint-disable-next-line functional/no-try-statements
  try {
    const ownPkg = readJsonFile<{ version: string }>(path.join(__dirname, '../package.json'));
    return `^${ownPkg.version}`;
  } catch {
    return 'latest';
  }
}

export type PublisherInitOptions = {
  /**
   * Working directory where to initialize (default: current working directory)
   */
  workingDir?: string;

  /**
   * Additional package specs to include as data sources alongside this package.
   * Each entry is a bare package name ("my-pkg") or a name with a semver constraint
   * ("my-pkg@^1.2.3"). They will be listed in package.json under `npmdata.additionalPackages`
   * and added to `dependencies`, so the generated CLI script will extract data from all of
   * them together with the data contained in the package being initialized.
   */
  additionalPackages?: string[];

  /**
   * When true, adds managed files to .gitignore in all generated npmdata entries.
   * Defaults to true. Set to false to disable.
   */
  gitignore?: boolean;

  /**
   * When true, mark all generated npmdata entries as unmanaged so that extracted
   * files are written without a .npmdata marker, without updating .gitignore, and
   * without being made read-only. Existing files are skipped rather than overwritten.
   * Defaults to false.
   */
  unmanaged?: boolean;
};

export type InitResult = {
  success: boolean;
  message: string;
  publishedFiles?: string[];
  additionalPackages?: string[];
  packageJsonPath?: string;
};

/**
 * Parse a package spec like "pkg@^1.0.0" or "@scope/pkg@2.x" into name and version.
 * Delegates to the shared utility; keeps 'latest' as default when no version is given.
 */
function parsePublisherPackageSpec(spec: string): { name: string; version: string } {
  const { name, version } = parsePackageSpec(spec);
  return { name, version: version ?? 'latest' };
}

function generateCliScript(): string {
  return `#!/usr/bin/env node

// DON'T EDIT THIS FILE MANUALLY - this script is generated by "npmdata init" command
require('npmdata/dist/runner.js').run(__dirname);
`;
}

// eslint-disable-next-line complexity
function preparePackageJson(
  fileGlobs: string[],
  workingDir: string,
  additionalPackages: string[] = [],
  gitignore = false,
  unmanaged = false,
): PublishablePackageJson {
  const packageJsonPath = path.join(workingDir, 'package.json');

  // eslint-disable-next-line functional/no-let
  let packageJson: PublishablePackageJson;

  if (fs.existsSync(packageJsonPath)) {
    packageJson = readJsonFile<PublishablePackageJson>(packageJsonPath);
  } else {
    packageJson = {
      name: path.basename(workingDir),
      version: '1.0.0',
    };
  }

  if (!packageJson.name) packageJson.name = path.basename(workingDir);
  if (!packageJson.version) packageJson.version = '1.0.0';

  const existingPatterns = (packageJson.files as string[]) ?? [];

  packageJson.files = Array.from(
    new Set([...fileGlobs, ...existingPatterns, 'package.json', 'bin/npmdata.js']),
  );

  if (!packageJson.dependencies) {
    packageJson.dependencies = {};
  }
  packageJson.dependencies.npmdata = getOwnVersion();

  // Build npmdata entries array: one entry per package (main + additional)
  const existingEntries: NpmdataExtractEntry[] = Array.isArray(packageJson.npmdata)
    ? (packageJson.npmdata as NpmdataExtractEntry[])
    : [];

  // Ensure the main package has an entry
  const mainName = packageJson.name;
  const hasMainEntry = existingEntries.some((e) => {
    const { name } = parsePackageSpec(e.package);
    return name === mainName;
  });
  if (!hasMainEntry) {
    existingEntries.push({ package: mainName, outputDir: '.' });
  }

  // Set file glob patterns and gitignore on all npmdata entries
  for (const entry of existingEntries) {
    entry.files = fileGlobs;
    if (gitignore) {
      entry.gitignore = true;
    }
    if (unmanaged) {
      entry.unmanaged = true;
    }
  }

  // Add additional packages as separate entries (dedup by package name)
  for (const pkgSpec of additionalPackages) {
    const { name: pkgName, version: pkgVersion } = parsePublisherPackageSpec(pkgSpec);
    const alreadyPresent = existingEntries.some((e) => {
      const { name } = parsePackageSpec(e.package);
      return name === pkgName;
    });
    if (!alreadyPresent) {
      existingEntries.push({
        package: pkgSpec,
        outputDir: '.',
        files: fileGlobs,
        ...(gitignore ? { gitignore: true } : {}),
        ...(unmanaged ? { unmanaged: true } : {}),
      });
    }
    if (!packageJson.dependencies[pkgName]) {
      packageJson.dependencies[pkgName] = pkgVersion;
    }
  }

  packageJson.npmdata = existingEntries;

  if (!packageJson.bin) {
    packageJson.bin = 'bin/npmdata.js';
  }

  return packageJson;
}

/**
 * Initialize publisher configuration with specified file glob patterns
 */
export async function initPublisher(
  fileGlobs: string[],
  options: PublisherInitOptions = {},
): Promise<InitResult> {
  const workingDir = options.workingDir ?? process.cwd();
  const additionalPackages = options.additionalPackages ?? [];
  const gitignore = options.gitignore ?? true;
  const unmanaged = options.unmanaged ?? false;

  // eslint-disable-next-line functional/no-try-statements
  try {
    if (!fileGlobs || fileGlobs.length === 0) {
      return {
        success: false,
        message:
          'npmdata: no file patterns specified. Usage: npmdata init --files "docs/**,data/**"',
      };
    }

    const packageJson = preparePackageJson(
      fileGlobs,
      workingDir,
      additionalPackages,
      gitignore,
      unmanaged,
    );
    const packageJsonPath = path.join(workingDir, 'package.json');
    writeJsonFile(packageJsonPath, packageJson);

    const cliScriptPath = path.join(workingDir, 'bin', 'npmdata.js');
    fs.mkdirSync(path.dirname(cliScriptPath), { recursive: true });
    fs.writeFileSync(cliScriptPath, generateCliScript(), 'utf8');
    fs.chmodSync(cliScriptPath, 0o755);

    const allEntries = packageJson.npmdata as NpmdataExtractEntry[];
    const finalAdditionalPackages = allEntries
      .filter((e) => {
        const { name } = parsePackageSpec(e.package);
        return name !== packageJson.name;
      })
      .map((e) => e.package);

    return {
      success: true,
      message: 'npmdata: project initialization completed successfully',
      publishedFiles: fileGlobs,
      additionalPackages:
        // eslint-disable-next-line no-undefined
        finalAdditionalPackages.length > 0 ? finalAdditionalPackages : undefined,
      packageJsonPath,
    };
  } catch (error) {
    return {
      success: false,
      message: `npmdata: initialization failed: ${String(error)}`,
    };
  }
}
